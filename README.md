#  자료구조와 알고리즘

이 레포지토리는 **자료구조의 개념을 학습하고**, **직접 구현한 코드와 정리된 내용을 기록**한 저장소입니다.  
각 자료구조를 스스로 구현하면서 내부 동작 원리를 정확히 이해하고, 알고리즘 학습을 위한 기반을 다지고자 합니다.

## 목차
- [목표](#목표)
- [구현방식](#구현-방식)
- [자료구조 목록](#자료구조-목록)
- [알고리즘 목록](#알고리즘-목록)
- [커밋 메시지 규칙](#커밋-메시지-규칙)
- [자료구조 전체 개념 정리 통합본](#자료구조-전체-개념-정리-통합본)
- [알고리즘 전체 개념 정리 통합본](#알고리즘-전체-개념-정리-통합본)

## 목표
- 자료구조의 동작 원리와 구조적 특징을 깊이 있게 이해하고 체계적으로 정리
- 다양한 자료구조를 직접 구현하며, 내부 작동 방식과 구현 원리를 명확히 습득
- 향후 알고리즘 설계와 문제 해결 능력 향상을 위한 탄탄한 기초를 다지기

## 구현 방식

- 모든 자료구조는 **Java** 언어로 직접 구현하였습니다.
- **기초 문법 위주로 직접 구현**하여, 자료구조의 핵심 동작 원리에 집중합니다.
- 각 폴더는 다음과 같은 구조로 구성됩니다:
    - `README.md`: 자료구조의 개념 및 특징 정리
    - `.java`: 직접 구현한 예제 코드

## 자료구조 목록

| 자료구조  | README 문서                  | 구현 코드                                          |
|:-----:|:---------------------------|:--------------------------------------------------|
| array | [배열 문서](./array/README.md) | [MyArrayList 구현](./array/MyArrayList.java)        |
| link  | [링크 문서](./link/README.md)  | [MyLinkedList 구현](./link/MyDoubleLinkedList.java) |
| stack | [스택 문서](./stack/README.md) | [MyStack 구현](./stack/MyStack.java)                |
| queue | [큐 문서](./queue/README.md)  | [MyQueue 구현](./queue/MyQueue.java)                |
| hash  | [해쉬 문서](./hash/README.md)  | [MyHashTable 구현](./hash/MyHashTable.java)<br>[MyHashMap 구현](./hash/MyHashMap.java) |
| tree  |                 | [MyBinarySearchTree 구현](./tree/MyBinarySearchTree.java) |

## 알고리즘 목록

| 알고리즘 | README 문서                                                                                                                                                                                                                                                             | 구현 코드                                                                                                                                    |
|:----:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------|
| 검색   | [검색 알고리즘](./search/README.md)                                                                                                                                                                                                                                       | [선형 검색](./search/LinearSearch.java)<br>[이진 검색](./search/BinerySearch.java)                                                               |
| 정렬   | [버블 정렬](./sort/bubble/README.md)<br>[선택 정렬](./sort/selection/README.md)<br>[삽입 정렬](./sort/insertion/README.md)<br>[퀵 정렬](./sort/quick/README.md)<br>[병합 정렬](./sort/merge/README.md)<br>[힙 정렬](./sort/heap/README.md) | [버블 정렬](./sort/bubble/BubbleSort.java)<br>[선택 정렬](./sort/selection/SelectionSort.java)<br>[삽입 정렬](./sort/insertion/InsertionSort.java)<br>[셸 정렬](./sort/insertion/ShellSort.java)|




## 커밋 메시지 규칙

### 커밋 메시지 작성 형식

`````
<type>(scope): <subject>

<body>

<footer>
`````

- **타입(type):** **필수**, 커밋 타입
- **스코프(scope):** **선택**, 변경된 폴더명이나 파일명 등, 괄호로 표기
- **제목(subject):** **필수**, 한 줄로 요약(50자 이내, 마침표 X, 명령문, 첫 글자 대문자)
- **본문(body):** **선택**, 변경 이유·내용 등 상세 설명(한 행은 72자 이내, 무엇·왜에 집중)
- **푸터(footer):** **선택**, 이슈 번호, 참고 자료 등 추가 정보

### 커밋 타입

| 타입 (Type) | 설명                              | 예시                              |
|-------------|---------------------------------|---------------------------------|
| feat        | 새로운 기능/코드 추가                 | feat(queue): 원형 큐 enqueue 기능 구현 |
| docs        | 문서 작성/수정 (README 등)           | docs(array): Array.md 오타 수정     |
| fix         | 버그 수정                          | fix(stack): pop 예외처리 버그 수정      |
| refactor    | 코드 리팩토링 (기능 변화 없음)         | refactor(tree): 중복 코드 함수로 분리    |
| test        | 테스트 코드 작성                    | test(graph): BFS 테스트 케이스 추가       |
| chore       | 기타 작업(폴더명 변경 등)             | chore: .gitignore 파일 추가          |

## 자료구조 전체 개념 정리 통합본

### 배열 (Array)

#### 📌 정의
고정된 크기의 **연속적인 메모리 공간**에 동일한 타입의 데이터를 저장하는 자료구조입니다.

```java
int[] arr = new int[5];
```

#### ⚙️ 특징
- 연속된 메모리 공간에 데이터 저장
- **크기와 타입이 고정** (생성 후 크기 변경 불가)
- **인덱스를 통한 직접 접근 가능**

#### ✅ 장점
- 인덱스를 통한 **빠른 접근** 가능 (O(1))
- 값의 변경은 인덱스를 통해 O(1)로 빠르게 수행
- **마지막 위치에 삽입/삭제**가 효율적

#### ❌ 단점
- **크기 변경 불가** → 유연성 부족
- **삽입/삭제 시 요소 이동 필요** (특히 중간/처음 위치)
- **공간 활용이 비효율적일 수 있음** (미리 큰 크기로 할당 시)

#### ⏱️ 시간 복잡도

| 연산    | 시간 복잡도 | 설명                              |
|---------|--------------|---------------------------------|
| 접근    | O(1)         | 인덱스를 통해 즉시 접근 가능                |
| 탐색    | O(n)         | 원하는 값을 찾기 위해 전체 순회 필요           |
| 삽입    | O(1) / O(n)  | 뒷 부분 삽입은 빠름 / 중간 또는 앞은 요소 이동 필요 |
| 삭제    | O(1) / O(n)  | 뒷 부분 삭제는 빠름 / 중간 또는 앞은 요소 이동 필요    |
| 값 변경 | O(1)         | 인덱스를 통한 값 변경                       |

---

### ArrayList

#### 📌 정의
Java의 **동적 배열 구현체**로, 내부적으로 배열을 사용하지만 **자동으로 크기가 확장**됩니다.

```java
List<String> list = new ArrayList<>();
```

#### ⚙️ 특징
- 내부적으로 배열 사용
- **크기 자동 확장** (동적 배열)
- **인덱스를 통한 직접 접근 가능**

#### ✅ 장점
- **빠른 인덱스 접근** (O(1))
- **동적 확장**으로 크기 제한이 없음 → 유연성 높음
- 사용이 간편하고, 다양한 메서드 지원

#### ❌ 단점
- **크기 확장 시 배열 복사로 인한 성능 저하** (O(n))
- **중간/처음 위치 삽입/삭제 시 느림** (요소 이동 필요)
- 내부 배열의 용량이 실제 데이터보다 클 경우 비어있는 공간이 생겨 **메모리 낭비** 가능

#### ⏱️ 시간 복잡도

| 연산    | 시간 복잡도 | 설명                             |
|---------|--------------|--------------------------------|
| 접근    | O(1)         | 인덱스를 통해 즉시 접근 가능               |
| 탐색    | O(n)         | 전체 순회 필요        |
| 삽입    | O(1) / O(n)  | 끝 삽입은 빠름 / 중간·앞 삽입은 이동 필요  |
| 삭제    | O(1) / O(n)  | 끝 삭제는 빠름 / 중간·앞 삭제는 이동 필요 |
| 값 변경 | O(1)         | 인덱스를 통한 값 변경                       |

---

## LinkedList

### 📌 정의
연결 리스트(LinkedList)는 각 **노드가 데이터와 다음 노드를 가리키는 포인터(링크)** 로 구성되어,
**순차적으로 연결된 자료구조**입니다.

```java
LinkedList<String> list = new LinkedList<>();
```

### ⚙️ 특징
- 각 노드는 **데이터 + 포인터**로 구성
- 메모리 공간은 **동적으로 할당됨** (크기 제한 없음)
- 인덱스를 통한 **직접 접근 불가** (순차 탐색 필요)

### ✅ 장점
- **앞·뒤 삽입/삭제가 빠름** (O(1))
- **크기 제한 없음** (메모리 재할당 필요 없음)
- 구조 변경 시 유연성 높음

### ❌ 단점
- **인덱스 접근 불가 → 탐색 느림** (O(n))
- **중간 삽입/삭제 시 느림** (순차 탐색 필요)
- 각 노드가 추가 메모리(포인터)를 사용하므로 **메모리 사용량 증가**

### ⏱️ 시간 복잡도

| 연산    | 시간 복잡도      | 설명                         |
|--------|-------------|----------------------------|
| 접근    | O(n)        | 순차 탐색 필요                   |
| 탐색    | O(n)        | 노드를 하나씩 따라가며 탐색            |
| 삽입    | O(1) / O(n) | 앞, 끝은 빠름 / 중간은 탐색  필요  |
| 삭제    | O(1) / O(n) | 앞, 끝은 빠름 / 중간은 탐색 필요  |
| 값 변경  | O(1) / O(n) | 앞, 끝은 빠름 / 중간은 탐색 필요       |

---

## Stack

### 📌 정의
**스택(Stack)** 은 **후입선출(LIFO, Last In First Out)** 구조를 가지는 선형 자료구조로,  
가장 **마지막에 넣은 데이터가 가장 먼저 나오는** 구조입니다.


```java
// 비권장 Vector를 상속해 구현됐으며(동기화 이슈로 성능 저하)
Stack<Integer> stack = new Stack<>();

// 권장
Deque<Integer> stack = new ArrayDeque<>();
```

### ⚙️ 특징
- **LIFO(후입 선출)** 방식으로 동작
- Top 포인터를 기준으로 삽입(push), 삭제(pop)
- 기본 연산: `push()`, `pop()`, `peek()`

### ✅ 장점
- **삽입/삭제가 빠름** (항상 Top에서만 수행 → O(1))
- 구조와 동작 원리가 간단하고 직관적
- 재귀적 문제 해결, 함수 호출 스택, 작업 기록 등에서 효과적

### ❌ 단점
- **중간 데이터 접근 불가**
- **인덱스 기반 순차 탐색 불가**  (전체 탐색 O(n))
- 데이터의 **순서나 특정 값 변경 불가** (Top 외 접근 불가)

### ⏱️ 시간 복잡도

| 연산          | 시간 복잡도 | 설명                    |
|-------------|--------|-----------------------|
| 접근          | O(n)   | 임의 접근 불가              |
| 탐색          | O(n)   | 원하는 값을 찾기 위해 전체 탐색 필요 |
| 삽입(Top 위치)  | O(1)   | Top에 바로 삽입 가능         |
| 삭제 (Top 위치) | O(1)   | Top에서 바로 삭제 가능     |
| 값 확인(Top위치) | O(1)   | Top의 값 바로 확인 가능             |

---

## Queue

### 📌 정의
**큐(Queue)** 는 **선입선출(FIFO, First In First Out)** 구조를 가지는 선형 자료구조로,  
가장 **먼저 넣은 데이터가 가장 먼저 나오는** 구조입니다.


```java
// 비권장 
Queue<Integer> queue = new Queue<>();

// 권장
Queue<Integer> queue = new ArrayDeque<>();

Queue<Integer> queue = new LinkedList<>();
```

### ⚙️ 특징
- **FIFO(선입 선출)** 방식으로 동작
- **Front**에서 데이터를 꺼내고, **Rear**에 데이터를 추가함
- 기본 연산: `offer()`, `poll()`, `peek()`

### ✅ 장점
- **삽입/삭제가 빠름** (`Front`, `Rear`에서 각각 O(1) 연산)
- 구조가 간단하여 **구현 및 사용이 직관적**
- 흐름 제어 및 순차적 처리에 적합 (ex. CPU 작업 큐)

### ❌ 단점
- **중간 데이터 접근 불가**
- **인덱스 기반 순차 탐색 불가**  (전체 탐색 O(n))
- 데이터의 **순서나 특정 값 변경 불가** (중간 접근 불가)

### ⏱️ 시간 복잡도

| 연산             | 시간 복잡도 | 설명              |
|----------------|--------|-----------------|
| 접근             | O(n)   | 임의 접근 불가        |
| 탐색             | O(n)   | 원하는 값을 찾기 위해 전체 탐색 필요 |
| 삽입(Rear 위치)    | O(1)   |  마지막에 삽입        |
| 삭제 (Front 위치)  | O(1)   |  첫 요소 제거    |
| 값 확인(Front 위치) | O(1)   | 가장 앞 요소 확인   |

---

## 해싱 (Hashing)

- 데이터를 **빠르게 저장하고 조회** 할 수 있도록 하는 기법
- **Key에 특정 연산(해시 함수)** 을 적용하여 **테이블의 저장 위치**를 계산

## Hash Function

- 임의의 데이터를 특정 값으로 매핑시키는 함수
- Java에서는 주로 객체의 hashCode() 메서드를 해시 함수로 사용
- 해시 함수의 시간 복잡도는 일반적으로 **O(1)**

## 해시 충돌

- 서로 다른 키가 **같은 해시값을 반환하는 경우**
- 해시 충돌이 발생하면, **같은 버킷(bucket)에 여러 데이터가 저장**
- 좋은 해시 함수는 충돌 가능성을 **최대한 낮게 설계**

## HashTable / HashMap

### 📌 정의
해시 기반 자료구조는 **Key-Value 쌍**으로 데이터를 저장하는 구조  
**해시 함수(Hash Function)** 를 통해 키(key)를 해시값으로 변환하여 데이터를 저장

```java
Map<String, Integer> map = new HashMap<>();
```

### ⚙️ 특징
- **Key-Value 구조**로 데이터를 저장함
- **중복된 키(key)는 허용되지 않음**
- **순서에 상관없이** 데이터를 **저장/조회**할 수 있음


### ✅ 장점
- 해시 충돌 없는 경우 **검색, 삽입, 삭제**가 **빠름** (평균 O(1))
- Key를 통해 직접 접근 → **빠르고 효율적인 조회**
- 데이터 양이 많아도 **성능 유지에 강함** (충돌이 적을 경우)

### ❌ 단점
- 해시 충돌 시 **성능 저하** (최악 O(n))
- 순서가 보장되지 않음 (단, LinkedHashMap 사용 시 순서 유지)

### ⏱️ 시간 복잡도

| 연산   | 평균 시간 복잡도 | 최악 시간 복잡도 | 설명                              |
|--------|-----------------|-----------------|---------------------------------|
| 접근   | -               | -               | 직접 인덱스 접근 불가            |
| 탐색   | O(1)            | O(n)            | 해시 충돌 시 버킷이 리스트로 작동 |
| 삽입   | O(1)            | O(n)            | 해시 충돌이 없는 경우 빠름       |
| 삭제   | O(1)            | O(n)            | 해시 충돌이 없는 경우 빠름            |

---

## 알고리즘 전체 개념 정리 통합본

## 검색 알고리즘 (Search Algorithms)

검색 알고리즘은 데이터 구조 내에서 특정 값을 찾는 방법입니다. 대표적인 검색 알고리즘으로 선형 검색과 이진 검색이 있습니다.

---

### 선형 검색 (Linear Search)

#### 📌 정의
선형 검색은 가장 단순한 검색 알고리즘으로, 배열의 첫 번째 요소부터 순차적으로 하나씩 비교하면서 원하는 값을 찾는 방법입니다.

#### ⚙️ 동작 원리
1. 배열의 첫 번째 요소부터 시작
2. 현재 요소가 찾는 값과 일치하는지 확인
3. 일치하면 해당 인덱스를 반환
4. 일치하지 않으면 다음 요소로 이동
5. 배열의 끝까지 반복
6. 찾지 못하면 -1 또는 null 반환

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(1) - 첫 번째 요소가 찾는 값인 경우
- **평균의 경우**: O(n) - 중간쯤에서 찾는 경우
- **최악의 경우**: O(n) - 마지막 요소이거나 값이 없는 경우

#### 💾 공간 복잡도
- O(1) - 추가 메모리 공간이 거의 필요 없음

#### ✅ 장점
- 구현이 매우 간단함
- 정렬되지 않은 데이터에서도 사용 가능
- 작은 데이터셋에서 효율적
- 추가 메모리가 필요 없음

#### ❌ 단점
- 데이터가 많을수록 비효율적
- 정렬된 데이터의 장점을 활용하지 못함

---

### 이진 검색 (Binary Search)

#### 📌 정의
이진 검색은 **정렬된 배열**에서 사용하는 효율적인 검색 알고리즘입니다. 중간값을 기준으로 검색 범위를 절반씩 줄여가며 원하는 값을 찾습니다.

⚠️ **배열이 반드시 정렬되어 있어야 합니다!**

#### ⚙️ 동작 원리
1. 배열의 중간 요소를 선택
2. 중간 요소가 찾는 값과 같으면 해당 인덱스 반환
3. 찾는 값이 중간 요소보다 작으면 왼쪽 절반에서 검색
4. 찾는 값이 중간 요소보다 크면 오른쪽 절반에서 검색
5. 검색 범위가 없어질 때까지 반복
6. 찾지 못하면 -1 또는 null 반환

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(1) - 중간 요소가 찾는 값인 경우
- **평균의 경우**: O(log n)
- **최악의 경우**: O(log n) - 검색 범위를 계속 절반씩 줄임

#### 💾 공간 복잡도
- **반복문 방식**: O(1)
- **재귀 방식**: O(log n) - 재귀 호출 스택

#### ✅ 장점
- 매우 빠른 검색 속도 (O(log n))
- 큰 데이터셋에서도 효율적
- 예측 가능한 성능

#### ❌ 단점
- 데이터가 반드시 정렬되어 있어야 함
- 정렬 비용이 추가로 필요할 수 있음
- 랜덤 접근이 불가능한 자료구조에서는 사용 불가 (예: 연결 리스트)

---

### 선형 검색 vs 이진 검색 비교

| 구분 | 선형 검색 | 이진 검색 |
|------|----------|----------|
| **시간 복잡도** | O(n) | O(log n) |
| **정렬 필요** | ❌ 불필요 | ✅ 필수 |
| **구현 난이도** | 쉬움 | 중간 |
| **공간 복잡도** | O(1) | O(1) ~ O(log n) |
| **적합한 데이터 크기** | 작은 데이터 | 큰 데이터 |

#### 성능 비교 예시
데이터 개수가 1,000,000개일 때:
- **선형 검색**: 최악의 경우 1,000,000번 비교
- **이진 검색**: 최악의 경우 약 20번 비교 (log₂ 1,000,000 ≈ 20)

---

## 정렬 알고리즘 (Sort Algorithms)

---

### 버블 정렬 (Bubble Sort)

#### 📌 정의
인접한 두 원소를 검사하여 정렬하는 알고리즘으로, 순서대로 되어 있지 않으면 교환합니다. 배열을 순회하면서 가장 큰 값을 맨 뒤로 "버블처럼 올려보내는" 방식입니다.

#### ⚙️ 동작 원리
1. 배열의 첫 번째 원소부터 인접한 원소끼리 비교
2. 앞의 원소가 뒤의 원소보다 크면 두 원소를 교환
3. 1회전이 끝나면 가장 큰 값이 맨 뒤로 이동
4. 다음 회전에서는 마지막 원소를 제외하고 반복
5. 모든 원소가 정렬될 때까지 반복

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(n) - 이미 정렬된 경우 (최적화된 버전)
- **평균의 경우**: O(n²)
- **최악의 경우**: O(n²) - 역순으로 정렬된 경우

#### 💾 공간 복잡도
- O(1) - 추가 메모리 공간이 거의 필요 없음

#### ✅ 장점
- 구현이 매우 간단하고 직관적
- 제자리 정렬(in-place sort)로 추가 메모리 공간이 거의 필요 없음
- 안정 정렬(stable sort) - 같은 값의 순서가 유지됨

#### ❌ 단점
- 시간 복잡도가 O(n²)로 **매우 비효율적**
- 배열의 크기가 커질수록 성능이 급격히 저하됨
- 실제 업무에서는 거의 사용되지 않음

---

### 선택 정렬 (Selection Sort)

#### 📌 정의
배열에서 **최솟값을 찾아** 맨 앞의 원소와 교환하는 정렬 알고리즘입니다. 정렬되지 않은 부분에서 가장 작은 값을 "선택"하여 정렬된 부분의 끝에 추가합니다.

#### ⚙️ 동작 원리
1. 배열 전체에서 최솟값을 찾음
2. 최솟값을 맨 앞의 원소와 교환
3. 정렬된 부분을 제외한 나머지에서 다시 최솟값을 찾음
4. 찾은 최솟값을 정렬되지 않은 부분의 맨 앞과 교환
5. 배열이 모두 정렬될 때까지 반복

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(n²) - 이미 정렬되어 있어도 최솟값을 찾기 위해 전체 순회
- **평균의 경우**: O(n²)
- **최악의 경우**: O(n²) - 역순으로 정렬된 경우

#### 💾 공간 복잡도
- **O(1)** - 추가 메모리 공간이 거의 필요 없음 (제자리 정렬)

#### ✅ 장점
- **구현이 간단**하고 이해하기 쉬움
- **제자리 정렬**(in-place sort)로 추가 메모리 공간이 거의 필요 없음
- **교환 횟수가 적음** - 최대 n-1번의 교환만 발생 (버블 정렬보다 적음)
- 작은 데이터셋에서는 효율적

#### ❌ 단점
- 시간 복잡도가 **O(n²)로 비효율적**
- **불안정 정렬**(unstable sort) - 같은 값의 순서가 바뀔 수 있음
- 이미 정렬된 배열이어도 **O(n²)의 시간이 소요됨**
- 큰 데이터셋에서는 매우 느림

---

### 삽입 정렬 (Insertion Sort)

#### 📌 정의
배열을 **정렬된 부분**과 **정렬되지 않은 부분**으로 나누어 정렬하는 알고리즘입니다. 정렬되지 않은 부분의 원소를 하나씩 꺼내어 정렬된 부분의 **적절한 위치에 삽입**합니다. 마치 카드 게임에서 손에 든 카드를 정렬하는 방식과 유사합니다.

#### ⚙️ 동작 원리
1. 두 번째 원소부터 시작하여 정렬된 부분과 비교
2. 현재 원소를 정렬된 부분에서 적절한 위치를 찾아 삽입
3. 정렬된 부분의 원소들을 오른쪽으로 이동시키며 자리를 만듦
4. 모든 원소가 정렬될 때까지 반복

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(n) - 이미 정렬된 경우 (각 원소마다 1번만 비교)
- **평균의 경우**: O(n²) - 무작위 데이터
- **최악의 경우**: O(n²) - 역순으로 정렬된 경우

#### 💾 공간 복잡도
- **O(1)** - 추가 메모리 공간이 거의 필요 없음 (제자리 정렬)

#### ✅ 장점
- **간단하고 직관적**인 구현
- **안정 정렬**(stable sort) - 같은 값의 순서가 유지됨
- **제자리 정렬**(in-place sort) - 추가 메모리가 거의 필요 없음
- **거의 정렬된 데이터**에서 매우 효율적 (O(n)에 가까움)
- **온라인 알고리즘** - 데이터가 들어오는 대로 정렬 가능
- **적응적**(adaptive) - 입력 데이터의 상태에 따라 성능이 달라짐

#### ❌ 단점
- 평균 및 최악의 경우 **O(n²)로 비효율적**
- 역순으로 정렬된 데이터에서 최악의 성능
- 큰 데이터셋에서는 성능 저하
- 배열이 클수록 원소 이동 비용이 증가

#### 🎯 사용 사례
- **작은 데이터셋 (n < 10~20)** - 원소가 적을 때는 충분히 빠름
- **거의 정렬된 데이터** - 최선의 경우 O(n)으로 매우 효율적
- **하이브리드 정렬 알고리즘의 일부** - 팀소트(Timsort), 인트로소트(Introsort)
- **온라인 정렬** - 데이터가 스트림으로 들어오는 경우

---

---

### 퀵 정렬 (Quick Sort)

#### 📌 정의
**분할 정복(Divide and Conquer)** 알고리즘을 사용하는 정렬 방식으로, **피벗(Pivot)** 을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하여 정렬합니다. 평균적으로 가장 빠른 정렬 알고리즘 중 하나입니다.

#### ⚙️ 동작 원리
1. 배열에서 **피벗(Pivot)** 을 선택
2. 피벗보다 작은 요소는 왼쪽으로, 큰 요소는 오른쪽으로 이동 (**분할, Partition**)
3. 피벗을 기준으로 배열이 두 부분으로 나뉨
4. 나뉜 두 부분 배열에 대해 **재귀적으로** 퀵 정렬 수행
5. 부분 배열의 크기가 1 이하가 되면 정렬 완료

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(n log n) - 피벗이 항상 중간값일 때
- **평균의 경우**: O(n log n)
- **최악의 경우**: O(n²) - 피벗이 항상 최솟값이나 최댓값일 때

#### 💾 공간 복잡도
- **O(log n)** - 재귀 호출 스택 (평균)

#### ✅ 장점
- **평균적으로 매우 빠름** - O(n log n)
- **제자리 정렬**(in-place sort) - 추가 메모리가 적게 필요함
- **캐시 효율성이 좋음** - 인접한 데이터를 비교
- **실무에서 가장 많이 사용**

#### ❌ 단점
- **불안정 정렬**(unstable sort)
- **최악의 경우 O(n²)** - 이미 정렬된 배열이나 피벗 선택이 나쁠 때
- 피벗 선택 전략에 따라 성능이 크게 달라짐

---

### 병합 정렬 (Merge Sort)

#### 📌 정의
**분할 정복(Divide and Conquer)** 알고리즘을 사용하는 정렬 방식으로, 배열을 **절반으로 나누어** 각각을 정렬한 후 **병합**하여 전체를 정렬합니다. **안정 정렬**이며 **최악의 경우에도 O(n log n)** 을 보장합니다.

#### ⚙️ 동작 원리
1. 배열을 **절반으로 분할** (Divide)
2. 각 부분을 **재귀적으로 정렬** (Conquer)
3. 정렬된 두 부분을 **병합** (Merge)
4. 부분 배열의 크기가 1이 될 때까지 반복

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(n log n)
- **평균의 경우**: O(n log n)
- **최악의 경우**: O(n log n) ⭐ 보장됨

#### 💾 공간 복잡도
- **O(n)** - 병합 과정에서 임시 배열 필요

#### ✅ 장점
- **안정 정렬**(stable sort) - 같은 값의 순서가 유지됨
- **최악의 경우에도 O(n log n) 보장** - 예측 가능한 성능
- **분할 정복으로 병렬 처리에 적합**
- **연결 리스트 정렬에 효율적**

#### ❌ 단점
- **추가 메모리 공간 필요** - O(n)의 보조 배열 필요
- **작은 데이터셋에서는 비효율적**
- **퀵 정렬보다 느림** - 평균적으로 실제 속도가 느림

#### 🎯 실무 활용
- Python의 `sorted()`, `list.sort()` - **Timsort** (병합 정렬 + 삽입 정렬)
- Java의 `Collections.sort()`, `Arrays.sort(객체 배열)` - **Timsort**

---

### 힙 정렬 (Heap Sort)

#### 📌 정의
**힙(Heap) 자료구조**를 이용한 정렬 알고리즘으로, **완전 이진 트리**를 기반으로 합니다. 최대 힙 또는 최소 힙을 구성하여 정렬하며, **제자리 정렬**이고 **최악의 경우에도 O(n log n)** 을 보장합니다.

#### ⚙️ 동작 원리
1. **힙 구성 (Heapify)**: 배열을 최대 힙으로 변환
2. **반복 과정**:
   - 루트(최댓값)와 마지막 요소 교환
   - 힙 크기를 1 감소
   - 루트에서 다시 힙 속성 복구
3. 모든 요소가 정렬될 때까지 반복

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(n log n)
- **평균의 경우**: O(n log n)
- **최악의 경우**: O(n log n) ⭐ 보장됨

#### 💾 공간 복잡도
- **O(1)** - 제자리 정렬 (추가 메모리 거의 불필요)

#### ✅ 장점
- **최악의 경우 O(n log n) 보장** - 예측 가능
- **제자리 정렬** - 메모리 효율적
- **우선순위 큐 구현**에 최적

#### ❌ 단점
- **불안정 정렬**(unstable sort)
- **실제 속도는 퀵 정렬보다 느림** - 캐시 효율성이 낮음
- 참조 지역성이 낮아 캐시 미스 발생 가능

#### 🎯 실무 활용
- C++ STL의 `std::sort()` - **Introsort** (QuickSort + HeapSort + InsertionSort)
- 우선순위 큐(Priority Queue) 구현
- Top-K 문제 해결

---

### 계수 정렬 (Counting Sort)

#### 📌 정의
**비교 기반이 아닌(Non-Comparison)** 정렬 알고리즘으로, 각 값의 **출현 횟수를 세어(Count)** 정렬하는 방식입니다. **정수** 또는 **범위가 제한된 값**을 정렬할 때 사용하며, **선형 시간 O(n + k)** 에 정렬 가능합니다.

#### ⚙️ 동작 원리
1. 입력 배열에서 **최댓값과 최솟값**을 찾음
2. 값의 범위만큼 **카운트 배열** 생성
3. 각 값의 **출현 횟수**를 카운트 배열에 저장
4. 카운트 배열을 **누적합**으로 변환
5. 입력 배열을 **역순으로 순회**하며 결과 배열에 배치

#### ⏱️ 시간 복잡도
- **최선의 경우**: O(n + k)
- **평균의 경우**: O(n + k)
- **최악의 경우**: O(n + k)
- **n**: 배열의 크기, **k**: 값의 범위

#### 💾 공간 복잡도
- **O(n + k)** - 카운트 배열과 결과 배열 필요

#### ✅ 장점
- **매우 빠른 속도** - O(n + k) 선형 시간
- **안정 정렬**(stable sort)
- **구현이 간단**
- 값의 범위가 작을 때 최적의 성능

#### ❌ 단점
- **값의 범위가 클 때 비효율적** - 메모리 낭비
- **추가 메모리 필요** - O(k) 카운트 배열
- **정수나 제한된 범위의 값만 가능**
- 희소 데이터에서 메모리 낭비

#### 🎯 사용 사례
- 작은 범위의 정수 정렬 (나이, 학년, 등급 등)
- 기수 정렬(Radix Sort)의 보조 알고리즘
- 문자열 정렬 (알파벳만 있는 경우)

---

### 정렬 알고리즘 전체 비교

| 정렬 알고리즘 | 최선 시간 복잡도 | 평균 시간 복잡도 | 최악 시간 복잡도 | 공간 복잡도 | 안정 정렬 | 비교 기반 |
|---------|------------|------------|------------|---------|-------|-------|
| 버블 정렬   | O(n)       | O(n²)      | O(n²)      | O(1)    | ✅     | ✅     |
| 선택 정렬   | O(n²)      | O(n²)      | O(n²)      | O(1)    | ❌     | ✅     |
| 삽입 정렬   | O(n)       | O(n²)      | O(n²)      | O(1)    | ✅     | ✅     |
| 퀵 정렬    | O(n log n) | O(n log n) | O(n²)      | O(log n)| ❌     | ✅     |
| 병합 정렬   | O(n log n) | O(n log n) | O(n log n) | O(n)    | ✅     | ✅     |
| 힙 정렬    | O(n log n) | O(n log n) | O(n log n) | O(1)    | ❌     | ✅     |
| 계수 정렬   | O(n + k)   | O(n + k)   | O(n + k)   | O(n + k)| ✅     | ❌     |

#### 정렬 알고리즘 선택 가이드

**작은 데이터 (n < 20)**
- ✅ 삽입 정렬 - 간단하고 빠름

**일반적인 정렬**
- ✅ 퀵 정렬 - 평균적으로 가장 빠름
- ✅ Introsort (C++ STL) - QuickSort + HeapSort

**안정 정렬이 필요한 경우**
- ✅ 병합 정렬, Timsort (Python, Java)
- ✅ 삽입 정렬 (작은 데이터)

**최악의 경우 보장 + 메모리 제약**
- ✅ 힙 정렬 - O(n log n) 보장, O(1) 공간

**작은 범위의 정수**
- ✅ 계수 정렬 - O(n + k) 선형 시간

**거의 정렬된 데이터**
- ✅ 삽입 정렬 - O(n)에 가까움
- ✅ Timsort - 적응적 정렬

#### 성능 비교 (실제 측정 기준)
```
데이터 크기: 1,000개
- 정렬된 데이터: 삽입 정렬 > 퀵 정렬 > 병합 정렬 > 힙 정렬
- 무작위 데이터: 퀵 정렬 > 힙 정렬 > 병합 정렬 > 삽입 정렬
- 역순 데이터: 병합 정렬 > 힙 정렬 > 퀵 정렬 > 삽입 정렬

데이터 크기: 10,000개 이상
- 모든 경우: 퀵 정렬 ≈ 병합 정렬 > 힙 정렬 >> 삽입 정렬 > 선택 정렬 > 버블 정렬

작은 범위 정수 (0-100)
- 계수 정렬이 모든 비교 기반 정렬보다 빠름
```