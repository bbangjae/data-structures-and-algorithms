# 버블 정렬 (Bubble Sort)

## 📌 정의
- 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 순서대로 되어 있지 않으면 교환
- 배열을 순회하면서 가장 큰 값을 맨 뒤로 "버블처럼 올려보내는" 방식

## 동작 원리
1. 배열의 첫 번째 원소부터 인접한 원소끼리 비교
2. 앞의 원소가 뒤의 원소보다 크면 두 원소를 교환
3. 1회전이 끝나면 가장 큰 값이 맨 뒤로 이동
4. 다음 회전에서는 마지막 원소를 제외하고 반복
5. 모든 원소가 정렬될 때까지 반복

## 예시
```
초기 배열: [5, 3, 8, 4, 2]

1회전: [3, 5, 4, 2, 8] - 8이 맨 뒤로
2회전: [3, 4, 2, 5, 8] - 5가 뒤에서 두 번째로
3회전: [3, 2, 4, 5, 8] - 4가 제자리로
4회전: [2, 3, 4, 5, 8] - 정렬 완료
```

##  특징

### ✅장점
- 구현이 매우 간단하고 직관적
- 제자리 정렬(in-place sort)로 추가 메모리 공간이 거의 필요 없음
- 안정 정렬(stable sort) - 같은 값의 순서가 유지됨

### ❌ 단점
- 시간 복잡도가 O(n²)로 **매우 비효율적**
- 배열의 크기가 커질수록 성능이 급격히 저하됨
- 실제 업무에서는 거의 사용되지 않음
- 최선의 경우에도 **모든 원소를 비교**해야 함 (최적화하지 않은 경우)

## 시간 복잡도
- **최선의 경우**: O(n) - 이미 정렬된 경우 (최적화된 버전)
- **평균의 경우**: O(n²)
- **최악의 경우**: O(n²) - 역순으로 정렬된 경우

## 공간 복잡도
- O(1) - 추가 메모리 공간이 거의 필요 없음

## 구현 예시


```java
private static int[] bubbleSort(int[] arr) {
   int n = arr.length;

   for (int i = 0; i < n - 1; i++) {
      for (int j = 0; j < n - 1 - i; j++) {
         if (arr[j] > arr[j + 1]) {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
         }
      }
   }
   return arr;
}
```