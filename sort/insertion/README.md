# 삽입 정렬 (Insertion Sort)

## 📌 정의
- 배열을 **정렬된 부분**과 **정렬되지 않은 부분**으로 나누어 정렬하는 알고리즘
- 정렬되지 않은 부분의 원소를 하나씩 꺼내어 정렬된 부분의 **적절한 위치에 삽입**
- 마치 카드 게임에서 손에 든 카드를 정렬하는 방식과 유사

## 동작 원리
1. 두 번째 원소부터 시작하여 정렬된 부분과 비교
2. 현재 원소를 정렬된 부분에서 적절한 위치를 찾아 삽입
3. 정렬된 부분의 원소들을 오른쪽으로 이동시키며 자리를 만듦
4. 모든 원소가 정렬될 때까지 반복

## 예시
```
초기 배열: [5, 3, 8, 4, 2]

1회전: [5] | [3, 8, 4, 2]  - 5는 이미 정렬됨
       key = 3, 3 < 5이므로 5를 오른쪽으로
       [3, 5] | [8, 4, 2]

2회전: [3, 5] | [8, 4, 2]
       key = 8, 8 > 5이므로 그대로
       [3, 5, 8] | [4, 2]

3회전: [3, 5, 8] | [4, 2]
       key = 4, 4를 적절한 위치에 삽입
       [3, 4, 5, 8] | [2]

4회전: [3, 4, 5, 8] | [2]
       key = 2, 2를 맨 앞에 삽입
       [2, 3, 4, 5, 8] - 정렬 완료!
```

## 특징

### ✅ 장점
- **간단하고 직관적**인 구현
- **안정 정렬**(stable sort) - 같은 값의 순서가 유지됨
- **제자리 정렬**(in-place sort) - 추가 메모리가 거의 필요 없음
- **거의 정렬된 데이터**에서 매우 효율적 (O(n)에 가까움)
- **온라인 알고리즘** - 데이터가 들어오는 대로 정렬 가능
- **적응적**(adaptive) - 입력 데이터의 상태에 따라 성능이 달라짐
- 작은 데이터셋에서 빠른 성능

### ❌ 단점
- 평균 및 최악의 경우 **O(n²)로 비효율적**
- 역순으로 정렬된 데이터에서 최악의 성능
- 큰 데이터셋에서는 성능 저하
- 배열이 클수록 원소 이동 비용이 증가

## 시간 복잡도
- **최선의 경우**: O(n) - 이미 정렬된 경우 (각 원소마다 1번만 비교)
- **평균의 경우**: O(n²) - 무작위 데이터
- **최악의 경우**: O(n²) - 역순으로 정렬된 경우
- **비교 횟수**: 최악 n(n-1)/2 번
- **이동 횟수**: 최악 n(n-1)/2 번

## 공간 복잡도
- **O(1)** - 추가 메모리 공간이 거의 필요 없음 (제자리 정렬)

## 구현 예시

### Java
```java
 public static int[] insertionSort(int[] arr) {
     int n = arr.length;
     
     for (int i = 1; i < n; i++) {
         int key = arr[i];  // 삽입할 원소
         int j = i - 1;
         
         // key보다 큰 원소들을 오른쪽으로 이동
         while (j >= 0 && arr[j] > key) {
             arr[j + 1] = arr[j];
             j--;
         }
         
         // key를 적절한 위치에 삽입
         arr[j + 1] = key;
     }
     
     return arr;
 }
```

## 삽입 정렬은 어디서 사용할까?

### 실제 사용 사례

1. **작은 데이터셋 (n < 10~20)**
   - 원소가 적을 때는 O(n²)이어도 충분히 빠름
   - 구현이 간단하여 오버헤드가 적음

2. **거의 정렬된 데이터** ⭐⭐⭐
   - 최선의 경우 O(n)으로 매우 효율적
   - 실시간으로 데이터가 추가되는 경우
   - 예: 로그 파일, 타임스탬프 데이터

3. **하이브리드 정렬 알고리즘의 일부** ⭐⭐
   - **팀소트(Timsort)**: Python의 `sorted()`, Java의 `Arrays.sort()` (객체)
   - **인트로소트(Introsort)**: C++ STL의 `std::sort()`
   - 퀵소트나 병합정렬에서 작은 부분 배열에 삽입 정렬 사용

4. **온라인 정렬**
   - 데이터가 스트림으로 들어오는 경우
   - 새로운 데이터를 받을 때마다 즉시 정렬된 위치에 삽입

5. **연결 리스트 정렬**
   - 연결 리스트에서는 삽입이 O(1)
   - 배열보다 삽입 정렬이 더 효율적

### 실무 사용 예시

```java
// Timsort의 일부 (Python, Java에서 사용)
public static void hybridSort(int[] arr) {
   int n = arr.length;

   // 1️⃣ 작은 구간은 삽입 정렬
   if (n < MIN_MERGE) {
      insertionSort(arr, 0, n - 1);
      return;
   }

   // 2️⃣ 큰 구간은 병합 정렬
   mergeSort(arr, 0, n - 1);
}

// 실시간 데이터 정렬
public class SortedStream {

    private final List<Integer> data = new ArrayList<>();

    // 새로운 데이터를 정렬된 위치에 삽입
    public void add(int value) {
        int i = data.size() - 1;

        // 삽입 정렬 로직: 뒤에서부터 비교하며 자리 이동
        data.add(value); // 임시로 뒤에 삽입
        while (i >= 0 && data.get(i) > value) {
            data.set(i + 1, data.get(i));
            i--;
        }
        data.set(i + 1, value);
    }
}
```

## 최적화 기법

### 1. 이진 삽입 정렬 (Binary Insertion Sort)
```java
public static int[] binaryInsertionSort(int[] arr) {
   int n = arr.length;

   for (int i = 1; i < n; i++) {
      int key = arr[i];

      // ① 이진 탐색으로 삽입 위치 찾기
      int left = 0;
      int right = i - 1;
      while (left <= right) {
         int mid = (left + right) / 2;
         if (arr[mid] > key) {
            right = mid - 1;
         } else {
            left = mid + 1;
         }
      }

      // ② 요소들을 오른쪽으로 한 칸씩 이동
      for (int j = i - 1; j >= left; j--) {
         arr[j + 1] = arr[j];
      }

      // ③ key를 삽입
      arr[left] = key;
   }

   return arr;
}
```
- 비교 횟수를 O(n log n)으로 줄임
- 하지만 이동 횟수는 여전히 O(n²)

## 성능 비교 (실제 측정)

```
데이터 크기: 1,000개 (빠른 → 느린)
- 정렬된 데이터: 삽입 정렬 ▶ 선택 정렬 ▶ 버블 정렬
- 무작위 데이터: 삽입 정렬 ≈ 선택 정렬 ▶ 버블 정렬
- 역순 데이터: 선택 정렬 ▶ 삽입 정렬 ≈ 버블 정렬

데이터 크기: 10,000개 이상
- 모든 경우: 퀵 정렬 ≈ 병합 정렬 ≈ 힙 정렬 ▶ 삽입 정렬 ≈ 선택 정렬 ▶ 버블 정렬
```

## 언제 사용해야 할까?

### ✅ 삽입 정렬을 사용하는 것이 좋은 경우
- 데이터가 거의 정렬되어 있을 때 ⭐⭐⭐
- 데이터 크기가 작을 때 (n < 20)
- 안정 정렬이 필요할 때
- 온라인 정렬이 필요할 때
- 단순함이 중요할 때

### ❌ 삽입 정렬을 피해야 하는 경우
- 데이터가 크고 무작위로 섞여있을 때
- 역순으로 정렬된 데이터
- 성능이 중요한 대용량 데이터

## 결론
- ✅ **거의 정렬된 데이터에 최적** - O(n)에 가까운 성능
- ✅ **작은 데이터셋에 효율적** - 실제 정렬 라이브러리에서 사용
- ✅ **안정 정렬** - 같은 값의 순서 유지
- ✅ **적응적** - 데이터 상태에 따라 성능 변화
- ⚠️ **큰 무작위 데이터에는 비효율적** - O(n²)

