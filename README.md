#  자료구조와 알고리즘

이 레포지토리는 **자료구조의 개념을 학습하고**, **직접 구현한 코드와 정리된 내용을 기록**한 저장소입니다.  
각 자료구조를 스스로 구현하면서 내부 동작 원리를 정확히 이해하고, 알고리즘 학습을 위한 기반을 다지고자 합니다.

## 목차
- [목표](#목표)
- [구현방식](#구현-방식)
- [자료구조 목록](#자료구조-목록)
- [커밋 메시지 규칙](#커밋-메시지-규칙)
- [자료구조 전체 개념 정리 통합본](#자료구조-전체-개념-정리-통합본)

## 목표
- 자료구조의 동작 원리와 구조적 특징을 깊이 있게 이해하고 체계적으로 정리
- 다양한 자료구조를 직접 구현하며, 내부 작동 방식과 구현 원리를 명확히 습득
- 향후 알고리즘 설계와 문제 해결 능력 향상을 위한 탄탄한 기초를 다지기

## 구현 방식

- 모든 자료구조는 **Java** 언어로 직접 구현하였습니다.
- **기초 문법 위주로 직접 구현**하여, 자료구조의 핵심 동작 원리에 집중합니다.
- 각 폴더는 다음과 같은 구조로 구성됩니다:
    - `README.md`: 자료구조의 개념 및 특징 정리
    - `.java`: 직접 구현한 예제 코드

## 자료구조 목록

| 자료구조  | README 링크                  | 예시 코드 링크                                          |
|:-----:|:---------------------------|:--------------------------------------------------|
| array | [배열 문서](./array/README.md) | [MyArrayList 구현](./array/MyArrayList.java)        |
| link  | [배열 문서](./link/README.md)  | [MyLinkedList 구현](./link/MyDoubleLinkedList.java) |
| stack | [배열 문서](./stack/README.md) | [MyStack 구현](./stack/MyStack.java)                |
| queue | [배열 문서](./queue/README.md) | [MyQueue 구현](./queue/MyQueue.java)                |




## 커밋 메시지 규칙

### 커밋 메시지 작성 형식

`````
<type>(scope): <subject>

<body>

<footer>
`````

- **타입(type):** **필수**, 커밋 타입
- **스코프(scope):** **선택**, 변경된 폴더명이나 파일명 등, 괄호로 표기
- **제목(subject):** **필수**, 한 줄로 요약(50자 이내, 마침표 X, 명령문, 첫 글자 대문자)
- **본문(body):** **선택**, 변경 이유·내용 등 상세 설명(한 행은 72자 이내, 무엇·왜에 집중)
- **푸터(footer):** **선택**, 이슈 번호, 참고 자료 등 추가 정보

### 커밋 타입

| 타입 (Type) | 설명                              | 예시                              |
|-------------|---------------------------------|---------------------------------|
| feat        | 새로운 기능/코드 추가                 | feat(queue): 원형 큐 enqueue 기능 구현 |
| docs        | 문서 작성/수정 (README 등)           | docs(array): Array.md 오타 수정     |
| fix         | 버그 수정                          | fix(stack): pop 예외처리 버그 수정      |
| refactor    | 코드 리팩토링 (기능 변화 없음)         | refactor(tree): 중복 코드 함수로 분리    |
| test        | 테스트 코드 작성                    | test(graph): BFS 테스트 케이스 추가       |
| chore       | 기타 작업(폴더명 변경 등)             | chore: .gitignore 파일 추가          |

## 자료구조 전체 개념 정리 통합본

### 배열 (Array)

#### 📌 정의
고정된 크기의 **연속적인 메모리 공간**에 동일한 타입의 데이터를 저장하는 자료구조입니다.

```java
int[] arr = new int[5];
```

#### ⚙️ 특징
- 연속된 메모리 공간에 데이터 저장
- **크기와 타입이 고정** (생성 후 크기 변경 불가)
- **인덱스를 통한 직접 접근 가능**

#### ✅ 장점
- 인덱스를 통한 **빠른 접근** 가능 (O(1))
- 값의 변경은 인덱스를 통해 O(1)로 빠르게 수행
- **마지막 위치에 삽입/삭제**가 효율적

#### ❌ 단점
- **크기 변경 불가** → 유연성 부족
- **삽입/삭제 시 요소 이동 필요** (특히 중간/처음 위치)
- **공간 활용이 비효율적일 수 있음** (미리 큰 크기로 할당 시)

#### ⏱️ 시간 복잡도

| 연산    | 시간 복잡도 | 설명                              |
|---------|--------------|---------------------------------|
| 접근    | O(1)         | 인덱스를 통해 즉시 접근 가능                |
| 탐색    | O(n)         | 원하는 값을 찾기 위해 전체 순회 필요           |
| 삽입    | O(1) / O(n)  | 뒷 부분 삽입은 빠름 / 중간 또는 앞은 요소 이동 필요 |
| 삭제    | O(1) / O(n)  | 뒷 부분 삭제는 빠름 / 중간 또는 앞은 요소 이동 필요    |
| 값 변경 | O(1)         | 인덱스를 통한 값 변경                       |

---

### ArrayList

#### 📌 정의
Java의 **동적 배열 구현체**로, 내부적으로 배열을 사용하지만 **자동으로 크기가 확장**됩니다.

```java
List<String> list = new ArrayList<>();
```

#### ⚙️ 특징
- 내부적으로 배열 사용
- **크기 자동 확장** (동적 배열)
- **인덱스를 통한 직접 접근 가능**

#### ✅ 장점
- **빠른 인덱스 접근** (O(1))
- **동적 확장**으로 크기 제한이 없음 → 유연성 높음
- 사용이 간편하고, 다양한 메서드 지원

#### ❌ 단점
- **크기 확장 시 배열 복사로 인한 성능 저하** (O(n))
- **중간/처음 위치 삽입/삭제 시 느림** (요소 이동 필요)
- 내부 배열의 용량이 실제 데이터보다 클 경우 비어있는 공간이 생겨 **메모리 낭비** 가능

#### ⏱️ 시간 복잡도

| 연산    | 시간 복잡도 | 설명                             |
|---------|--------------|--------------------------------|
| 접근    | O(1)         | 인덱스를 통해 즉시 접근 가능               |
| 탐색    | O(n)         | 전체 순회 필요        |
| 삽입    | O(1) / O(n)  | 끝 삽입은 빠름 / 중간·앞 삽입은 이동 필요  |
| 삭제    | O(1) / O(n)  | 끝 삭제는 빠름 / 중간·앞 삭제는 이동 필요 |
| 값 변경 | O(1)         | 인덱스를 통한 값 변경                       |

---

## LinkedList

### 📌 정의
연결 리스트(LinkedList)는 각 **노드가 데이터와 다음 노드를 가리키는 포인터(링크)** 로 구성되어,
**순차적으로 연결된 자료구조**입니다.

```java
LinkedList<String> list = new LinkedList<>();
```

### ⚙️ 특징
- 각 노드는 **데이터 + 포인터**로 구성
- 메모리 공간은 **동적으로 할당됨** (크기 제한 없음)
- 인덱스를 통한 **직접 접근 불가** (순차 탐색 필요)

### ✅ 장점
- **앞·뒤 삽입/삭제가 빠름** (O(1))
- **크기 제한 없음** (메모리 재할당 필요 없음)
- 구조 변경 시 유연성 높음

### ❌ 단점
- **인덱스 접근 불가 → 탐색 느림** (O(n))
- **중간 삽입/삭제 시 느림** (순차 탐색 필요)
- 각 노드가 추가 메모리(포인터)를 사용하므로 **메모리 사용량 증가**

### ⏱️ 시간 복잡도

| 연산    | 시간 복잡도      | 설명                         |
|--------|-------------|----------------------------|
| 접근    | O(n)        | 순차 탐색 필요                   |
| 탐색    | O(n)        | 노드를 하나씩 따라가며 탐색            |
| 삽입    | O(1) / O(n) | 앞, 끝은 빠름 / 중간은 탐색  필요  |
| 삭제    | O(1) / O(n) | 앞, 끝은 빠름 / 중간은 탐색 필요  |
| 값 변경  | O(1) / O(n) | 앞, 끝은 빠름 / 중간은 탐색 필요       |

---

## Stack

### 📌 정의
**스택(Stack)** 은 **후입선출(LIFO, Last In First Out)** 구조를 가지는 선형 자료구조로,  
가장 **마지막에 넣은 데이터가 가장 먼저 나오는** 구조입니다.


```java
// 비권장 Vector를 상속해 구현됐으며(동기화 이슈로 성능 저하)
Stack<Integer> stack = new Stack<>();

// 권장
Deque<Integer> stack = new ArrayDeque<>();
```

### ⚙️ 특징
- **LIFO(후입 선출)** 방식으로 동작
- Top 포인터를 기준으로 삽입(push), 삭제(pop)
- 기본 연산: `push()`, `pop()`, `peek()`

### ✅ 장점
- **삽입/삭제가 빠름** (항상 Top에서만 수행 → O(1))
- 구조와 동작 원리가 간단하고 직관적
- 재귀적 문제 해결, 함수 호출 스택, 작업 기록 등에서 효과적

### ❌ 단점
- **중간 데이터 접근 불가**
- **인덱스 기반 순차 탐색 불가**  (전체 탐색 O(n))
- 데이터의 **순서나 특정 값 변경 불가** (Top 외 접근 불가)

### ⏱️ 시간 복잡도

| 연산          | 시간 복잡도 | 설명                    |
|-------------|--------|-----------------------|
| 접근          | O(n)   | 임의 접근 불가              |
| 탐색          | O(n)   | 원하는 값을 찾기 위해 전체 탐색 필요 |
| 삽입(Top 위치)  | O(1)   | Top에 바로 삽입 가능         |
| 삭제 (Top 위치) | O(1)   | Top에서 바로 삭제 가능     |
| 값 확인(Top위치) | O(1)   | Top의 값 바로 확인 가능             |

---

## Queue

### 📌 정의
**큐(Queue)** 는 **선입선출(FIFO, First In First Out)** 구조를 가지는 선형 자료구조로,  
가장 **먼저 넣은 데이터가 가장 먼저 나오는** 구조입니다.


```java
// 비권장 
Queue<Integer> queue = new Queue<>();

// 권장
Queue<Integer> queue = new ArrayDeque<>();

Queue<Integer> queue = new LinkedList<>();
```

### ⚙️ 특징
- **FIFO(선입 선출)** 방식으로 동작
- **Front**에서 데이터를 꺼내고, **Rear**에 데이터를 추가함
- 기본 연산: `offer()`, `poll()`, `peek()`

### ✅ 장점
- **삽입/삭제가 빠름** (`Front`, `Rear`에서 각각 O(1) 연산)
- 구조가 간단하여 **구현 및 사용이 직관적**
- 흐름 제어 및 순차적 처리에 적합 (ex. CPU 작업 큐)

### ❌ 단점
- **중간 데이터 접근 불가**
- **인덱스 기반 순차 탐색 불가**  (전체 탐색 O(n))
- 데이터의 **순서나 특정 값 변경 불가** (중간 접근 불가)

### ⏱️ 시간 복잡도

| 연산             | 시간 복잡도 | 설명              |
|----------------|--------|-----------------|
| 접근             | O(n)   | 임의 접근 불가        |
| 탐색             | O(n)   | 원하는 값을 찾기 위해 전체 탐색 필요 |
| 삽입(Rear 위치)    | O(1)   |  마지막에 삽입        |
| 삭제 (Front 위치)  | O(1)   |  첫 요소 제거    |
| 값 확인(Front 위치) | O(1)   | 가장 앞 요소 확인   |