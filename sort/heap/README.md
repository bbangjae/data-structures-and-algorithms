# 힙 정렬 (Heap Sort)

## 📌 정의
- **힙(Heap) 자료구조**를 이용한 정렬 알고리즘
- **완전 이진 트리**를 기반으로 하는 정렬 방식
- 최대 힙(Max Heap) 또는 최소 힙(Min Heap)을 구성하여 정렬
- **제자리 정렬**(in-place sort)이며 **최악의 경우에도 O(n log n)** 보장

## 힙(Heap)이란?

### 힙의 특징
- **완전 이진 트리**(Complete Binary Tree) 구조
- **힙 속성**(Heap Property)을 만족
  - **최대 힙**: 부모 노드 ≥ 자식 노드
  - **최소 힙**: 부모 노드 ≤ 자식 노드
- 배열로 표현 가능

### 배열에서 힙 인덱스
```
부모 인덱스 = (i - 1) / 2
왼쪽 자식 인덱스 = 2 * i + 1
오른쪽 자식 인덱스 = 2 * i + 2
```

### 최대 힙 예시
```
        9
       / \
      7   6
     / \ / \
    5  3 4  2

배열: [9, 7, 6, 5, 3, 4, 2]
```

## 동작 원리

### 오름차순 정렬 (최대 힙 사용)
1. **힙 구성 (Heapify)**: 배열을 최대 힙으로 변환
2. **반복 과정**:
   - 루트(최댓값)와 마지막 요소 교환
   - 힙 크기를 1 감소
   - 루트에서 다시 힙 속성 복구(heapify)
3. 모든 요소가 정렬될 때까지 반복

## 예시
```
초기 배열: [4, 10, 3, 5, 1]

1단계: 최대 힙 구성
       10
      /  \
     5    3
    / \
   4   1
배열: [10, 5, 3, 4, 1]

2단계: 루트(10)와 마지막 요소(1) 교환
배열: [1, 5, 3, 4, | 10]
힙 복구 → [5, 4, 3, 1, | 10]

3단계: 루트(5)와 마지막 요소(1) 교환
배열: [1, 4, 3, | 5, 10]
힙 복구 → [4, 1, 3, | 5, 10]

4단계: 루트(4)와 마지막 요소(3) 교환
배열: [3, 1, | 4, 5, 10]
힙 복구 → [3, 1, | 4, 5, 10]

5단계: 루트(3)와 마지막 요소(1) 교환
배열: [1, | 3, 4, 5, 10]

최종 결과: [1, 3, 4, 5, 10]
```

## 특징

### ✅ 장점
- **최악의 경우에도 O(n log n) 보장** ⭐
- **제자리 정렬**(in-place sort) - 추가 메모리가 거의 필요 없음
- **예측 가능한 성능** - 항상 O(n log n)
- **우선순위 큐 구현**에 활용 가능
- 메모리 사용량이 적음

### ❌ 단점
- **불안정 정렬**(unstable sort) - 같은 값의 순서가 바뀔 수 있음
- **실제 속도는 퀵 정렬보다 느림** - 캐시 효율성이 낮음
- **구현이 복잡** - 다른 O(n²) 정렬보다 복잡
- 참조 지역성이 낮아 캐시 미스 발생 가능

## 시간 복잡도
- **최선의 경우**: O(n log n)
- **평균의 경우**: O(n log n)
- **최악의 경우**: O(n log n) ⭐ 보장됨

### 분석
- **힙 구성**: O(n)
- **정렬 과정**: n번의 삭제 × O(log n) = O(n log n)
- **전체**: O(n) + O(n log n) = O(n log n)

## 공간 복잡도
- **O(1)** - 제자리 정렬 (추가 메모리 거의 불필요)
- 재귀를 반복문으로 구현 시 스택 메모리도 불필요

## 정렬 알고리즘 비교

| 구분 | 힙 정렬 | 퀵 정렬 | 병합 정렬 |
|------|--------|---------|----------|
| **평균 시간 복잡도** | O(n log n) | O(n log n) | O(n log n) |
| **최악 시간 복잡도** | O(n log n) ⭐ | O(n²) | O(n log n) ⭐ |
| **공간 복잡도** | O(1) ⭐ | O(log n) | O(n) |
| **안정 정렬** | ❌ | ❌ | ✅ |
| **제자리 정렬** | ✅ | ✅ | ❌ |
| **실제 속도** | 보통 | 빠름 | 보통 |
| **캐시 효율성** | 낮음 | 높음 | 보통 |

## 사용 사례

### ✅ 힙 정렬을 사용하는 것이 좋은 경우
- **최악의 경우 O(n log n) 보장이 필요하면서 메모리가 제한적일 때** 
- **제자리 정렬이 필요할 때** - 병합 정렬의 대안
- **우선순위 큐가 필요한 경우** - 힙 자료구조 활용
- **Top-K 문제** - K개의 최대/최소값 찾기
- 안정 정렬이 필요하지 않을 때

### ❌ 힙 정렬을 피해야 하는 경우
- **평균 성능이 중요할 때** - 퀵 정렬이 더 빠름
- **안정 정렬이 필요할 때** - 병합 정렬 사용
- **캐시 효율성이 중요할 때**
- **작은 데이터셋** - 삽입 정렬이 더 빠를 수 있음

## 실무 활용

### 우선순위 큐 (Priority Queue)
```java
// Java의 PriorityQueue는 내부적으로 힙 사용
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(5);
pq.offer(2);
pq.offer(8);
int min = pq.poll();  // 2 (최솟값)
```


### 스트리밍 데이터의 중앙값 찾기
```java
// 최대 힙 + 최소 힙 조합
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
```

## 힙 정렬 vs 다른 O(n log n) 정렬

### 퀵 정렬과 비교
- **장점**: 최악의 경우 보장, 제자리 정렬
- **단점**: 평균적으로 느림, 캐시 비효율적

### 병합 정렬과 비교
- **장점**: 제자리 정렬 (메모리 효율적)
- **단점**: 불안정 정렬, 실제 속도 비슷

## 결론
- ✅ **최악의 경우 O(n log n) 보장** - 예측 가능
- ✅ **제자리 정렬** - 메모리 효율적 (O(1))
- ✅ **우선순위 큐 구현**에 최적
- ✅ **Top-K 문제**에 효과적
- ⚠️ **평균적으로 퀵 정렬보다 느림** - 캐시 비효율적
- ⚠️ **불안정 정렬** - 안정성 필요 시 병합 정렬
- 🎯 **사용 시나리오**: 최악의 경우 보장 + 메모리 제약 + 안정성 불필요