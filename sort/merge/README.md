# 병합 정렬 (Merge Sort)

## 📌 정의
- **분할 정복(Divide and Conquer)** 알고리즘을 사용하는 정렬 방식
- 배열을 **절반으로 나누어** 각각을 정렬한 후 **병합**하여 전체를 정렬
- **안정 정렬**(stable sort)이며 **최악의 경우에도 O(n log n)** 보장

## 동작 원리
1. 배열을 **절반으로 분할** (Divide)
2. 각 부분을 **재귀적으로 정렬** (Conquer)
3. 정렬된 두 부분을 **병합** (Merge)
4. 부분 배열의 크기가 1이 될 때까지 반복

## 예시
```
초기 배열: [5, 3, 8, 4, 9, 1, 7, 2]

1단계: 분할 (Divide)
[5, 3, 8, 4] | [9, 1, 7, 2]

2단계: 더 분할
[5, 3] [8, 4] | [9, 1] [7, 2]

3단계: 개별 요소까지 분할
[5] [3] [8] [4] | [9] [1] [7] [2]

4단계: 병합 시작 (Merge)
[3, 5] [4, 8] | [1, 9] [2, 7]

5단계: 계속 병합
[3, 4, 5, 8] | [1, 2, 7, 9]

6단계: 최종 병합
[1, 2, 3, 4, 5, 7, 8, 9]
```

## 특징

### ✅ 장점
- **안정 정렬**(stable sort) - 같은 값의 순서가 유지됨
- **최악의 경우에도 O(n log n) 보장** - 예측 가능한 성능
- **분할 정복으로 병렬 처리에 적합** - 멀티스레드 환경에서 유리
- **연결 리스트 정렬에 효율적** - 추가 메모리 없이 정렬 가능
- 큰 데이터셋에서 안정적인 성능

### ❌ 단점
- **추가 메모리 공간 필요** - O(n)의 보조 배열 필요 (제자리 정렬 아님)
- **작은 데이터셋에서는 비효율적** - 오버헤드가 큼
- **퀵 정렬보다 느림** - 평균적으로 실제 속도가 느림
- 메모리 사용량이 많아 메모리 제약이 있는 환경에서 부담

## 시간 복잡도
- **최선의 경우**: O(n log n)
- **평균의 경우**: O(n log n)
- **최악의 경우**: O(n log n)

### 분석
- **분할 단계**: log n 번 (배열을 절반씩 나눔)
- **병합 단계**: 각 단계마다 n 번 비교
- **전체**: n × log n = O(n log n)

## 공간 복잡도
- **O(n)** - 병합 과정에서 임시 배열 필요
- 배열의 경우 추가 메모리 필수
- 연결 리스트의 경우 O(1) 가능



## 병합 정렬 vs 퀵 정렬

| 구분 | 병합 정렬 | 퀵 정렬 |
|------|----------|---------|
| **평균 시간 복잡도** | O(n log n) | O(n log n) |
| **최악 시간 복잡도** | O(n log n) ⭐ | O(n²) |
| **공간 복잡도** | O(n) | O(log n) |
| **안정 정렬** | ✅ | ❌ |
| **제자리 정렬** | ❌ | ✅ |
| **실제 속도** | 느림 | 빠름 (평균) |
| **최악의 경우 보장** | ✅ | ❌ |

## 사용 사례

### ✅ 병합 정렬을 사용하는 것이 좋은 경우
- **안정 정렬이 필요할 때**  - 같은 값의 순서 유지
- **최악의 경우에도 O(n log n) 보장이 필요할 때** 
- **연결 리스트를 정렬할 때** - 추가 메모리 없이 가능
- **외부 정렬(External Sort)** - 대용량 파일 정렬
- **병렬 처리가 필요할 때** - 멀티스레드 환경
- **예측 가능한 성능이 중요할 때**

### ❌ 병합 정렬을 피해야 하는 경우
- **메모리가 제한적일 때** - O(n) 추가 메모리 필요
- **작은 데이터셋** - 오버헤드가 큼
- **일반적인 정렬** - 퀵 정렬이 평균적으로 더 빠름
- **제자리 정렬이 필요할 때**

## 결론
- ✅ **안정 정렬** - 같은 값의 순서 유지
- ✅ **최악의 경우에도 O(n log n) 보장** - 예측 가능
- ✅ **연결 리스트 정렬에 최적**
- ✅ **병렬 처리에 적합**
- ✅ **외부 정렬에 사용**
- ⚠️ **O(n) 추가 메모리 필요** - 제자리 정렬 아님
- ⚠️ **평균적으로 퀵 정렬보다 느림**
- ⭐ **실무에서 널리 사용** - Python, Java 표준 정렬 (Timsort)