# 선택 정렬 (Selection Sort)

## 📌 정의
- 배열에서 **최솟값을 찾아** 맨 앞의 원소와 교환하는 정렬 알고리즘
- 정렬되지 않은 부분에서 가장 작은 값을 "선택"하여 정렬된 부분의 끝에 추가
- 제자리 정렬(in-place sort) 알고리즘

## 동작 원리
1. 배열 전체에서 최솟값을 찾음
2. 최솟값을 맨 앞의 원소와 교환
3. 정렬된 부분을 제외한 나머지에서 다시 최솟값을 찾음
4. 찾은 최솟값을 정렬되지 않은 부분의 맨 앞과 교환
5. 배열이 모두 정렬될 때까지 반복

## 예시
```
초기 배열: [5, 3, 8, 4, 2]

1회전: [2, 3, 8, 4, 5] - 최솟값 2를 첫 번째 위치로
2회전: [2, 3, 8, 4, 5] - 최솟값 3은 이미 제자리
3회전: [2, 3, 4, 8, 5] - 최솟값 4를 세 번째 위치로
4회전: [2, 3, 4, 5, 8] - 최솟값 5를 네 번째 위치로
정렬 완료: [2, 3, 4, 5, 8]
```

## 특징

### ✅ 장점
- **구현이 간단**하고 이해하기 쉬움
- **제자리 정렬**(in-place sort)로 추가 메모리 공간이 거의 필요 없음
- **교환 횟수가 적음** - 최대 n-1번의 교환만 발생 (버블 정렬보다 적음)
- 작은 데이터셋에서는 효율적
- 데이터 이동이 적어서 데이터가 큰 경우 유리할 수 있음

### ❌ 단점
- 시간 복잡도가 **O(n²)로 비효율적**
- **불안정 정렬**(unstable sort) - 같은 값의 순서가 바뀔 수 있음
- 이미 정렬된 배열이어도 **O(n²)의 시간이 소요됨**
- 최선, 평균, 최악의 경우 모두 동일한 시간 복잡도
- 큰 데이터셋에서는 매우 느림

## 시간 복잡도
- **최선의 경우**: O(n²) - 이미 정렬되어 있어도 최솟값을 찾기 위해 전체 순회
- **평균의 경우**: O(n²)
- **최악의 경우**: O(n²) - 역순으로 정렬된 경우
- **비교 횟수**: n(n-1)/2 번

## 공간 복잡도
- **O(1)** - 추가 메모리 공간이 거의 필요 없음 (제자리 정렬)

## 구현 예시

### Java
```java
public class SelectionSort {
    public static int[] selectionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            // 최솟값의 인덱스 찾기
            int minIndex = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            // 최솟값과 현재 위치 교환
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
        
        return arr;
    }
}
```
