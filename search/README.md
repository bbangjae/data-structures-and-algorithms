# 검색 알고리즘 (Search Algorithms)

검색 알고리즘은 데이터 구조 내에서 특정 값을 찾는 방법

---

## 선형 검색 (Linear Search)

### 개념
- 선형 검색은 가장 단순한 검색 알고리즘 
- 배열의 첫 번째 요소부터 순차적으로 하나씩 비교하면서 원하는 값을 찾는 방법

### 동작 원리
1. 배열의 첫 번째 요소부터 시작
2. 현재 요소가 찾는 값과 일치하는지 확인
3. 일치하면 해당 인덱스를 반환
4. 일치하지 않으면 다음 요소로 이동
5. 배열의 끝까지 반복
6. 찾지 못하면 -1 또는 null 반환

### 특징
- **정렬 여부**: 정렬되지 않은 데이터에서도 사용 가능
- **구현 난이도**: 매우 쉬움
- **데이터 구조**: 배열, 연결 리스트 등 모든 순차 자료구조에 적용 가능

### 시간 복잡도
- **최선의 경우**: O(1) - 첫 번째 요소가 찾는 값인 경우
- **평균의 경우**: O(n) - 중간쯤에서 찾는 경우
- **최악의 경우**: O(n) - 마지막 요소이거나 값이 없는 경우

### 공간 복잡도
- O(1) - 추가 메모리 공간이 거의 필요 없음

### 장점
- 구현이 매우 간단함
- 정렬되지 않은 데이터에서도 사용 가능
- 작은 데이터셋에서 효율적
- 추가 메모리가 필요 없음

### 단점
- 데이터가 많을수록 비효율적
- 정렬된 데이터의 장점을 활용하지 못함

### 사용 사례
- 작은 크기의 배열
- 정렬되지 않은 데이터
- 한 번만 검색하는 경우
- 데이터가 자주 변경되는 경우

---

## 이진 검색 (Binary Search)

### 개념
- 이진 검색은 **정렬된 배열**에서 사용하는 효율적인 검색 알고리즘  
- 중간값을 기준으로 검색 범위를 절반씩 줄여가며 원하는 값을 찾습니다.

### 전제 조건
⚠️ **배열이 반드시 정렬되어 있어야 합니다!**

### 동작 원리
1. 배열의 중간 요소를 선택
2. 중간 요소가 찾는 값과 같으면 해당 인덱스 반환
3. 찾는 값이 중간 요소보다 작으면 왼쪽 절반에서 검색
4. 찾는 값이 중간 요소보다 크면 오른쪽 절반에서 검색
5. 검색 범위가 없어질 때까지 반복
6. 찾지 못하면 -1 또는 null 반환

### 예시
배열 `[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`에서 `7`을 찾는 경우:

```
1단계: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
                    ↑ 중간값 9
       9 > 7 → 왼쪽 절반 탐색

2단계: [1, 3, 5, 7, 9]
             ↑ 중간값 5
       5 < 7 → 오른쪽 절반 탐색

3단계: [7, 9]
        ↑ 중간값 7
       7 == 7 → 찾음! (인덱스 3 반환)
```

### 특징
- **정렬 여부**: 반드시 정렬된 데이터 필요
- **구현 난이도**: 중간 (반복문 또는 재귀)
- **데이터 구조**: 배열 또는 랜덤 접근이 가능한 자료구조

### 시간 복잡도
- **최선의 경우**: O(1) - 중간 요소가 찾는 값인 경우
- **평균의 경우**: O(log n)
- **최악의 경우**: O(log n) - 검색 범위를 계속 절반씩 줄임

### 공간 복잡도
- **반복문 방식**: O(1)
- **재귀 방식**: O(log n) - 재귀 호출 스택

### 장점
- 매우 빠른 검색 속도 (O(log n))
- 큰 데이터셋에서도 효율적
- 예측 가능한 성능

### 단점
- 데이터가 반드시 정렬되어 있어야 함
- 정렬 비용이 추가로 필요할 수 있음
- 랜덤 접근이 불가능한 자료구조에서는 사용 불가 (예: 연결 리스트)

### 사용 사례
- 정렬된 대용량 데이터
- 여러 번 검색해야 하는 경우
- 데이터베이스 인덱스
- 전화번호부, 사전 검색

---

## 선형 검색 vs 이진 검색 비교

| 구분 | 선형 검색 | 이진 검색 |
|------|----------|----------|
| **시간 복잡도** | O(n) | O(log n) |
| **정렬 필요** | ❌ 불필요 | ✅ 필수 |
| **구현 난이도** | 쉬움 | 중간 |
| **공간 복잡도** | O(1) | O(1) ~ O(log n) |
| **적합한 데이터 크기** | 작은 데이터 | 큰 데이터 |
| **데이터 구조** | 모든 순차 구조 | 배열, 랜덤 접근 가능 구조 |

### 성능 비교 예시
데이터 개수가 1,000,000개일 때:
- **선형 검색**: 최악의 경우 1,000,000번 비교
- **이진 검색**: 최악의 경우 약 20번 비교 (log₂ 1,000,000 ≈ 20)

---

## 언제 어떤 검색을 사용할까?

### 선형 검색을 사용하는 경우
- 데이터가 정렬되어 있지 않은 경우
- 데이터 크기가 작은 경우 (< 100개)
- 한 번만 검색하는 경우 (정렬 비용이 더 클 때)
- 연결 리스트 같은 순차 접근 자료구조

### 이진 검색을 사용하는 경우
- 데이터가 이미 정렬되어 있는 경우
- 데이터 크기가 큰 경우 (> 100개)
- 여러 번 검색해야 하는 경우
- 빠른 검색 속도가 중요한 경우

---

## 구현 예시

### 선형 검색

```java
public static int linearSearch(int[] arr, int x) {
    int n = arr.length;
    
    for (int i = 0; i < n; i++) {
        if (arr[i] == x) {
            return i;
        }
    }
    return -1;
}
```

### 이진 검색 

```java

public static int binarySearch(int[] arr, int x) {
    int left = 0;
    int right = arr.length -1;
    
    while(left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == x) {
            return mid;
        }
        
        if (arr[mid] < x) {
            left = mid + 1;
        }

        if (arr[mid] > x) {
            right = mid - 1;
        }
    }
    return -1;
}
```
