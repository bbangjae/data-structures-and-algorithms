# 퀵 정렬 (Quick Sort)

## 📌 정의
- **분할 정복(Divide and Conquer)** 알고리즘을 사용하는 정렬 방식
- **피벗(Pivot)** 을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하여 정렬
- 평균적으로 가장 빠른 정렬 알고리즘 중 하나

## 동작 원리
1. 배열에서 **피벗(Pivot)** 을 선택 (보통 첫 번째, 마지막, 또는 중간 요소)
2. 피벗보다 작은 요소는 왼쪽으로, 큰 요소는 오른쪽으로 이동 (**분할, Partition**)
3. 피벗을 기준으로 배열이 두 부분으로 나뉨
4. 나뉜 두 부분 배열에 대해 **재귀적으로** 퀵 정렬 수행
5. 부분 배열의 크기가 1 이하가 되면 정렬 완료

## 예시
```
초기 배열: [5, 3, 8, 4, 9, 1, 7]
피벗 선택: 5 (첫 번째 요소)

1단계: 분할
[3, 4, 1] < 5 < [8, 9, 7]

2단계: 왼쪽 부분 [3, 4, 1] 정렬
피벗: 3
[1] < 3 < [4]

3단계: 오른쪽 부분 [8, 9, 7] 정렬
피벗: 8
[7] < 8 < [9]

최종 결과: [1, 3, 4, 5, 7, 8, 9]
```

## 특징

### ✅ 장점
- **평균적으로 매우 빠름** - O(n log n)
- **제자리 정렬**(in-place sort) - 추가 메모리가 적게 필요함 (O(log n) 스택 공간)
- **캐시 효율성이 좋음** - 인접한 데이터를 비교하여 참조 지역성이 높음
- **실무에서 가장 많이 사용** - 평균 성능이 뛰어남
- 대부분의 경우 병합 정렬보다 빠름

### ❌ 단점
- **불안정 정렬**(unstable sort) - 같은 값의 순서가 바뀔 수 있음
- **최악의 경우 O(n²)** - 이미 정렬된 배열이나 피벗 선택이 나쁠 때
- **재귀 호출**로 인한 스택 오버플로우 가능성 (깊이가 깊을 때)
- 피벗 선택 전략에 따라 성능이 크게 달라짐

## 시간 복잡도
- **최선의 경우**: O(n log n) - 피벗이 항상 중간값일 때
- **평균의 경우**: O(n log n)
- **최악의 경우**: O(n²) - 피벗이 항상 최솟값이나 최댓값일 때 (이미 정렬된 배열)

## 공간 복잡도
- **O(log n)** - 재귀 호출 스택 (평균)
- **O(n)** - 최악의 경우 재귀 깊이

## 퀵 정렬 vs 병합 정렬

| 구분 | 퀵 정렬 | 병합 정렬 |
|------|---------|----------|
| **평균 시간 복잡도** | O(n log n) | O(n log n) |
| **최악 시간 복잡도** | O(n²) | O(n log n) |
| **공간 복잡도** | O(log n) | O(n) |
| **안정 정렬** | ❌ | ✅ |
| **제자리 정렬** | ✅ | ❌ |
| **캐시 효율성** | 높음 | 보통 |
| **실제 속도** | 더 빠름 (평균) | 안정적 |

## 사용 사례

### ✅ 퀵 정렬을 사용하는 것이 좋은 경우
- **평균적인 성능이 중요할 때** ⭐
- **메모리 공간이 제한적일 때** - 제자리 정렬
- **대부분의 일반적인 정렬 작업** - 평균적으로 가장 빠름
- **캐시 효율성이 중요할 때**
- 안정 정렬이 필요하지 않을 때

### ❌ 퀵 정렬을 피해야 하는 경우
- **최악의 경우를 피해야 할 때** - 보장된 O(n log n) 필요
- **안정 정렬이 필요할 때** - 같은 값의 순서 유지
- **이미 정렬된 데이터가 입력될 가능성이 높을 때** (기본 피벗 선택 시)
- **스택 오버플로우가 우려될 때**

## 실무 활용

```java
// Arrays.sort()는 기본 타입에 대해 Dual-Pivot Quick Sort 사용
Arrays.sort(intArray);

// Collections.sort()는 객체에 대해 Timsort(병합 정렬 기반) 사용
Collections.sort(list);
```


## 결론
- ✅ **평균적으로 가장 빠른 정렬** - O(n log n)
- ✅ **제자리 정렬** - 메모리 효율적
- ✅ **캐시 효율성 좋음** - 실제 성능 우수
- ✅ **실무에서 가장 많이 사용** - 대부분의 프로그래밍 언어 표준 라이브러리
- ⚠️ **최악의 경우 O(n²)** - 피벗 선택 전략 중요
- ⚠️ **불안정 정렬** - 안정성 필요 시 병합 정렬 사용